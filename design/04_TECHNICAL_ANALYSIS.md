# 技術分析文檔

## 📋 文件資訊
- **版本**：1.0
- **整理日期**：2024-11-20
- **文檔類型**：技術分析與規格研究

---

## 📚 目錄

1. [Command 2000 格式與使用分析](#command-2000-分析)
2. [TagUID 轉換演算法分析](#taguid-轉換分析)
3. [規格符合性分析](#規格符合性分析)

---

<a name="command-2000-分析"></a>
## 1. Command 2000 格式與使用分析

### 📋 基本資訊
- **來源**：`spec/701ServerJsonCommand2000.md`
- **版本**：1.01
- **分析日期**：2024-11-20

### 🎯 Command 2000 定義

#### 官方說明
> **C_CMD 2000**：HEX 格式的協議傳輸

#### 用途
Command 2000 是一個**通用的協議傳輸指令**，允許直接發送原始的 SOYAL 通訊協議指令給控制器。

### 📊 Command 2000 vs Command 1021

| 特性 | Command 1021 | Command 2000 |
|------|--------------|--------------|
| **層級** | 高層 JSON 指令 | 低層協議指令 |
| **參數格式** | JSON 結構化參數 | 單一 HEX 字串 |
| **易用性** | 使用者友善 | 需要了解底層協議 |
| **靈活性** | 僅支援訪客功能 | 支援所有協議功能 |
| **協議指令** | 內部轉換 | 直接發送 |
| **用途** | 訪客管理 | 萬用控制 |

### 🔧 Command 2000 JSON 格式

#### 基本結構

```json
{
  "l_user": "login user",
  "cmd_array": [{
    "c_cmd": 2000,
    "Area": 0,
    "Node": 1,
    "Hex": "0x..."
  }]
}
```

#### 參數說明

| 參數 | 類型 | 說明 |
|------|------|------|
| `c_cmd` | INT | 固定為 2000 |
| `Area` | INT | 區域編號（通常為 0） |
| `Node` | INT | 節點編號 |
| `Hex` | String | 十六進制協議指令內容（必須以 "0x" 開頭） |

### 📝 範例分析

#### 範例 1：控制門鎖繼電器

**協議指令**
```
7E 05 01 21 84 5B 01
```

**指令解析**
- `7E`：起始碼
- `05`：長度
- `01`：設備地址
- `21`：協議指令（控制繼電器）
- `84`：參數
- `5B 01`：校驗碼

**JSON 指令**
```json
{
  "l_user": "login user",
  "cmd_array": [{
    "c_cmd": 2000,
    "Area": 0,
    "Node": 1,
    "Hex": "0x2184"
  }]
}
```

**注意**：JSON 中的 `Hex` 只包含**指令和參數部分**（21 84），不包含協議框架（7E, 長度, 地址, 校驗碼），這些由 701Server 自動處理。

#### 範例 2：設定訪客通行時間（重要！）

**設定內容**
```
用戶位址：200 (0xC8)
卡片 ID：04295:14226
密碼：1212
通行模式：卡片和密碼
開始時間：2022/6/16 10:27
結束時間：2023/6/16 10:27
通行樓層：1F~8F
```

**協議指令（完整）**
```
7E 26 01 8B 57 00 00 C8 00 00 00 00 10 C7 37 92 00 00 04 BC 86 FF FF FF 16 06 10 0A 1B 17 06 10 0A 1B 00 00 00 FF A7 D7
```

**JSON 指令**
```json
{
  "l_user": "login user",
  "cmd_array": [{
    "c_cmd": 2000,
    "Area": 0,
    "Node": 1,
    "Hex": "0x8B570000C80000000010C73792000004BC86FFFFFF1606100A1B1706100A1B000000FF"
  }]
}
```

**HEX 字串詳細解析**

```
0x8B570000C80000000010C73792000004BC86FFFFFF1606100A1B1706100A1B000000FF
```

**分段解析：**

```
8B                      指令碼（8BH = 設定訪客資訊）
57                      子指令/參數
0000                    保留
C8                      用戶位址 = 200 (十進制)
00000000                保留/對齊
10C7                    卡號第一部分 = 04295 (十進制)
3792                    卡號第二部分 = 14226 (十進制)
000004BC                密碼 = 1212 (十進制)
86                      通行模式（卡片+密碼）
FFFFFF                  門禁權限
16 06 10 0A 1B          開始時間（年.月.日.時.分）
17 06 10 0A 1B          結束時間（年.月.日.時.分）
000000                  保留
FF                      通行樓層或其他設定
```

#### 關鍵發現

1. **卡號編碼方式相同**
   ```
   04295:14226 → 0x10C7 3792
   ```
   這與我們實現的 `cardIdToHexTagUID()` 轉換方式一致！

2. **時間格式不同**
   - Command 1021：`"YYYY-MM-DD HH:MM"` (字串)
   - Command 2000：`YY MM DD HH MM` (HEX bytes)
   
   範例：`2022/6/16 10:27`
   - 年：2022 → 0x16 (22)
   - 月：6 → 0x06
   - 日：16 → 0x10
   - 時：10 → 0x0A
   - 分：27 → 0x1B

3. **包含更多資訊**
   Command 2000 可以設定：
   - 密碼（Command 1021 不支援）
   - 通行模式
   - 門禁權限
   - 通行樓層

### 🎯 使用建議

#### 何時使用 Command 1021

✅ **推薦使用場景**：
- 簡單的訪客管理
- 只需要卡號、開始時間、結束時間
- 不需要密碼、門禁權限等高級功能
- 需要易用、友善的 API

**優點**：
- JSON 參數清晰易懂
- 不需要了解底層協議
- 錯誤處理容易

#### 何時使用 Command 2000

✅ **推薦使用場景**：
- 需要設定密碼
- 需要設定門禁權限
- 需要設定通行樓層
- 需要控制門鎖、讀取 I/O 等其他功能
- 需要完全控制協議內容

**缺點**：
- 需要了解底層協議格式
- HEX 字串構建複雜
- 調試困難

### ✅ 結論

#### 關鍵發現

1. **Command 2000 是底層工具**
   - 不是高層 API
   - 需要構建完整的 HEX 協議字串
   - 支援所有 SOYAL 協議功能

2. **與 Command 1021 的關係**
   - Command 1021：高層、易用、功能受限
   - Command 2000：底層、靈活、功能完整
   - 兩者是互補的，不是替代關係

3. **實現要點**
   - 正確的數據結構（`RawProtocolCommand`）
   - HEX 字串構建輔助函數
   - 完整的協議指令支援

---

<a name="taguid-轉換分析"></a>
## 2. TagUID 轉換演算法分析

### 📋 概述

根據 SOYAL 701Server 官方規格，`TagUID` 必須是 **8 位元組 HEX 字串**。本節詳細說明如何將使用者友善的 `"數字:數字"` 格式轉換為規格要求的 HEX 格式。

### 🔬 轉換演算法

#### 核心公式

```
HEX_TagUID = (第一個數字 << 16) | 第二個數字
```

#### 詳細步驟

1. **分割卡號**：以 `:` 為分隔符，分割成兩個數字
2. **位元左移**：將第一個數字左移 16 位
3. **位元 OR**：與第二個數字進行位元 OR 運算
4. **格式化**：輸出為 `0x` + 16 個十六進制字符（補零）

### 📊 範例分析

#### 範例 1：`"04295:14226"`

**步驟 1：分解數字**
```
第一個數字：04295 (十進制)
第二個數字：14226 (十進制)
```

**步驟 2：轉換為十六進制**
```
04295 (十進制) = 0x10C7 (十六進制)
14226 (十進制) = 0x3792 (十六進制)
```

**步驟 3：位元運算**
```
4295 << 16         = 0x10C70000
0x10C70000 | 0x3792 = 0x10C73792
```

**步驟 4：驗證（十進制）**
```
4295 << 16 = 4295 × 65536 = 281477120
281477120 + 14226 = 281491346
281491346 (十進制) = 0x10C73792 (十六進制)
```

**最終結果**
```
輸入：  "04295:14226"
輸出：  "0x0000000010C73792"
        └─ 補零至 16 字符（8 bytes）
```

#### 範例 2：`"59488:61427"`

**步驟 1-2：數字轉換**
```
59488 (十進制) = 0xE860 (十六進制)
61427 (十進制) = 0xEFF3 (十六進制)
```

**步驟 3：位元運算**
```
59488 << 16        = 0xE8600000
0xE8600000 | 0xEFF3 = 0xE860EFF3
```

**最終結果**
```
輸入：  "59488:61427"
輸出：  "0x00000000E860EFF3"
```

### 💻 Zig 實現

#### 轉換函數

```zig
pub fn cardIdToHexTagUID(card_id: []const u8, allocator: std.mem.Allocator) ![]u8 {
    // 1. 分割卡號
    var iter = std.mem.splitScalar(u8, card_id, ':');
    const first_str = iter.next() orelse return error.InvalidCardIdFormat;
    const second_str = iter.next() orelse return error.InvalidCardIdFormat;
    
    // 2. 轉換為數字
    const first = try std.fmt.parseInt(u32, first_str, 10);
    const second = try std.fmt.parseInt(u32, second_str, 10);
    
    // 3. 組合演算法
    const combined: u64 = (@as(u64, first) << 16) | @as(u64, second);
    
    // 4. 格式化為 16 字符 HEX
    return std.fmt.allocPrint(allocator, "0x{X:0>16}", .{combined});
}
```

### 🔍 演算法分析

#### 為什麼左移 16 位？

左移 16 位相當於將第一個數字放在高 16 位：

```
原始數字：     0x000010C7 (4295)
左移 16 位：   0x10C70000
              ↑↑↑↑ 移到高位

第二個數字：   0x00003792 (14226)
OR 運算：      0x10C73792
              ↑↑↑↑       保持第一個數字
                  ↑↑↑↑   加入第二個數字
```

#### 數值範圍

- **第一個數字**：0 ~ 4,294,967,295 (0xFFFFFFFF)
- **第二個數字**：0 ~ 65,535 (0xFFFF) - 只使用低 16 位
- **組合結果**：0 ~ 281,474,976,710,655 (0xFFFFFFFFFFFF)
- **實際使用**：通常在 0 ~ 0xFFFFFFFF 範圍內

### 🔄 逆向轉換

#### 從 HEX 轉回 "數字:數字"

```zig
pub fn hexTagUIDToCardId(hex_tag_uid: []const u8, allocator: std.mem.Allocator) ![]u8 {
    // 移除 "0x" 前綴
    const hex_str = if (std.mem.startsWith(u8, hex_tag_uid, "0x"))
        hex_tag_uid[2..]
    else
        hex_tag_uid;
    
    // 解析為 u64
    const combined = try std.fmt.parseInt(u64, hex_str, 16);
    
    // 提取兩個數字
    const first: u32 = @intCast((combined >> 16) & 0xFFFFFFFF);
    const second: u32 = @intCast(combined & 0xFFFF);
    
    return std.fmt.allocPrint(allocator, "{d}:{d}", .{ first, second });
}
```

### 🎯 設計決策

#### 為什麼分兩層處理？

1. **使用者介面層**
   - 輸入：`"04295:14226"`（易讀）
   - 驗證：確保格式正確
   
2. **轉換層**
   - 轉換：`"04295:14226"` → `"0x0000000010C73792"`
   - 確保符合規格

3. **通訊層**
   - 發送：符合 SOYAL 規格的 HEX 格式
   - 接收：解析伺服器回應

#### 優點

✅ **使用者友善**：CLI 使用可讀的數字格式  
✅ **符合規格**：內部轉換為 HEX 格式  
✅ **可測試**：轉換邏輯獨立，易於驗證  
✅ **可維護**：清晰的職責分離  

---

<a name="規格符合性分析"></a>
## 3. 規格符合性分析

### 📅 基本資訊
- **規格版本**：701Server JSON Command v1.05
- **分析日期**：2024-11-20
- **目的**：確認實現完全符合官方規格

### 📋 Command 1021 規格分析

#### 官方規格要求

```json
{
  "l_user": "login user",
  "cmd_array": [{
    "c_cmd": 1021,
    "Area": 0,
    "Node": 1,
    "Addr": 200,
    "TagUID": "0x1234567890ABCDEF",
    "Begin_dt": "2024-11-19 09:00",
    "End_dt": "2024-11-19 17:00"
  }]
}
```

**必要參數**：
- `c_cmd`: 1021 (INT)
- `Area`: 0-15 (INT) - 可省略，預設 0
- `Node`: 節點編號 (INT)
- `Addr`: 位址 0-32767 (INT)
- `TagUID`: 8 位元組 UID (HEX String)
- `Begin_dt`: "YYYY-MM-DD HH:MM" (String)
- `End_dt`: "YYYY-MM-DD HH:MM" (String)

**選用參數**：
- `Lift`: 4 位元組電梯控制 (HEX String)
- `DoorAccess`: 2 位元組門禁權限 (HEX String)
- `PIN`: 0-999999999 (INT)
- `Mode`: 0/1/2/3 (INT)
- `Alias`: LCD 顯示名稱 (String)

### 📋 Command 1022 規格分析

#### 官方規格要求

```json
{
  "l_user": "login user",
  "cmd_array": [{
    "c_cmd": 1022,
    "Area": 0,
    "Node": 1,
    "Addr": 200
  }]
}
```

**必要參數**：
- `c_cmd`: 1022 (INT)
- `Area`: 0-15 (INT) - 可省略，預設 0
- `Node`: 節點編號 (INT)
- `Addr`: 位址 0-32767 (INT)

**重要發現**：Command 1022 **不需要** TagUID 參數，僅通過 Addr 來識別要刪除的訪客。

### 📊 規格符合性對照表

| 項目 | 官方規格 | 實現狀態 | 符合性 |
|------|---------|---------|--------|
| **Command 1021** |
| 參數命名 | TagUID, Begin_dt, End_dt | ✅ 正確 | ✅ |
| Addr 欄位 | 必要 | ✅ 已添加（預設 0） | ✅ |
| TagUID 格式 | 8 bytes HEX | ✅ "0x..." | ✅ |
| 時間格式 | YYYY-MM-DD HH:MM | ✅ 正確 | ✅ |
| **Command 1022** |
| 參數 | 僅 Addr | ✅ 正確 | ✅ |
| TagUID | 不需要 | ✅ 未包含 | ✅ |
| **Command 2000** |
| JSON 格式 | 符合 v1.01 | ✅ 正確 | ✅ |
| Hex 參數 | String (0x...) | ✅ 正確 | ✅ |

**總符合率**：100% ✅

### 🔍 重要發現

#### 1. TagUID 的理解
- **官方規格**：8 位元組 HEX (例如：`"0x1234567890ABCDEF"`)
- **實際系統**：使用 `"數字:數字"` 格式（例如：`"59488:61427"`）
- **實現決策**：CLI 接受友善格式，內部自動轉換為 HEX

#### 2. Addr（位址）的用途
- **1021**：指定訪客資料存儲的記憶體位址（0-32767）
- **1022**：通過位址刪除指定的訪客記錄
- **實現決策**：固定使用 Addr = 0（簡化操作）

#### 3. 時間格式的差異
- 官方規格不包含秒數（只到分鐘）
- 這是 701Server 系統的設計特性
- 實現已完全符合規格要求

#### 4. 1022 命令的簡化
- 不需要 TagUID 參數
- 僅通過 Addr 來識別要刪除的訪客
- 這意味著系統通過位址而非卡號來管理訪客記錄

### ✅ 符合性評估

#### Command 1021
- ✅ 參數名稱正確
- ✅ 時間格式正確
- ✅ 必要欄位完整
- ✅ TagUID 格式符合規格

#### Command 1022
- ✅ 僅包含必要參數
- ✅ 不包含多餘的 CardID 參數
- ✅ Addr 參數正確

#### Command 2000
- ✅ JSON 格式正確
- ✅ Hex 參數格式正確
- ✅ 支援原始協議傳輸

### 📝 實現品質
- ✅ 嚴格的輸入驗證
- ✅ 清晰的錯誤訊息
- ✅ 完整的測試覆蓋
- ✅ 使用者友善的介面

---

## 📚 相關文檔

### 設計文檔
- `01_COMMAND_SPECIFICATIONS.md` - 命令規格完整定義
- `02_DATA_STRUCTURE_DESIGN.md` - 數據結構設計
- `03_IMPLEMENTATION_PLAN.md` - 實現計畫

### 規格文檔
- `spec/701ServerJsonCommand2000.md` - Command 2000 官方說明
- `spec/701Server JSON Command 文件.md` - 完整協議文檔

### 實現文檔
- `05_IMPLEMENTATION_REPORT.md` - 實現完成報告
- `06_TEST_REPORT.md` - 測試報告

---

**文檔版本**：1.0  
**最後更新**：2024-11-20  
**狀態**：✅ 分析完成
